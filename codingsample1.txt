import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.FileSystems;
import java.nio.file.Path;
import java.util.Comparator;
import java.util.HashMap;
import java.util.PriorityQueue;

//Author: Connor Quigley
public  class  Huffman {

	public void compress(String pathName, String pathNameCompressed) throws IOException, Exception
	{


		BufferedReader input=new BufferedReader(new FileReader(pathName));


		HashMap<Character,Integer> frequencyMap=new HashMap<Character,Integer>();
		int cInt=input.read();
		//Boundary Case: Empty File
		if(cInt==-1)
		{
			throw new Exception("Empty File");
		}

		while(cInt!=-1)
		{
			char c=(char)cInt;
			//generate a frequency table
			//if the character is already in the map, increment its frequency value, otherwise, put the character in the map
			if(frequencyMap.get(c)!=null)
			{
				frequencyMap.put(c, frequencyMap.get(c)+1);
			}
			else
			{
				frequencyMap.put(c, 1);
			}
			cInt=input.read();
		}
		BinaryTree<HuffData> huffTree;
		String huffTreeString="";
		//Boundary Case: Only one Letter
		if(frequencyMap.size()==1)
		{
			char loneChar=(char)frequencyMap.keySet().toArray()[0];
			compressHelperSingleLetter(loneChar+":"+frequencyMap.get(loneChar),pathName,pathNameCompressed, frequencyMap.get(loneChar));
			return;
		}
		//adding letters and their frequencies to the minPQ, also building a string to represent the tree's data
		PriorityQueue<BinaryTree<HuffData>> minFreqQueue=new PriorityQueue<BinaryTree<HuffData>>(new TreeComparator());
		for(char c: frequencyMap.keySet())
		{
			minFreqQueue.add(new BinaryTree<HuffData>(new HuffData(c,frequencyMap.get(c))));
			huffTreeString+=c+":"+frequencyMap.get(c)+"<>";
		}

		//building the binary tree
		while(minFreqQueue.size()>1)
		{
			BinaryTree<HuffData> T1=minFreqQueue.remove();
			BinaryTree<HuffData> T2=minFreqQueue.remove();
			BinaryTree<HuffData> combine=new BinaryTree<HuffData>(new HuffData('a',T1.getData().getFrequency()+T2.getData().getFrequency()),T1,T2);
			minFreqQueue.add(combine);
		}



		huffTree=minFreqQueue.remove();
		HashMap<Character, String> charToCode=new HashMap<Character, String>();
		mapCharToCode(charToCode,"",huffTree);	//helper method maps characters to code in the charToCode HashMap
		compressHelper(new BufferedReader(new FileReader(pathName)),charToCode,huffTreeString,pathNameCompressed); //helper method that does file writing
	}

	//a recursive method that adds characters and their code to a hashMap, traverses the tree only once
	public void mapCharToCode(HashMap<Character, String> build, String soFar, BinaryTree<HuffData> curr)
	{

		if(curr.isLeaf())
		{
			build.put(curr.getData().getCharacter(), soFar);
		}
		else
		{
			mapCharToCode(build,soFar+"0",curr.getLeft());
			mapCharToCode(build,soFar+"1",curr.getRight());
		}
	}

	public void decompress(String pathNameDecompressed, String pathNameCompressed) throws Exception
	{

		BufferedBitReader bitReader=new BufferedBitReader(pathNameCompressed);
		//string builders are used to help me read the treeCode in from the front of the file
		StringBuilder binary=new StringBuilder();
		StringBuilder tree=new StringBuilder();
		while(bitReader.hasNext())
		{
			boolean bit=bitReader.readBit();
			if(bit)
			{
				binary.append('1');

			}
			else
			{
				binary.append('0');
			}
			if(binary.length()==8)
			{
				//00000000 is a special character that signifies the end of the treecode, this idea comes from CBK October 17 2017
				if(binary.toString().equals("00000000"))
				{

					break;

				}
				tree.append(binary.toString());
				binary=new StringBuilder();

			}
		}

		//code to convert from bits to String from https://stackoverflow.com/questions/8634527/converting-binary-data-to-characters-in-java accessed on October 17 2017
		String treeCode="";
		for (int i = 0; i < tree.length()/8; i++)
		{

			int a = Integer.parseInt(tree.substring(8*i,(i+1)*8),2);
			treeCode += (char)(a);
		}

		BufferedWriter output = new BufferedWriter(new FileWriter(pathNameDecompressed));

		BinaryTree<HuffData> top=stringToBT(treeCode); //uses a helper method that converts the tree code into a BT
		BinaryTree<HuffData> curr=top;


		while (bitReader.hasNext())
		{
			boolean bit = bitReader.readBit();
			if(bit)
			{
				curr=curr.getRight();
			}
			else
			{
				curr=curr.getLeft();
			}
			if(curr.isLeaf())
			{
				output.write(curr.getData().getCharacter());
				curr=top;
			}
		}
		output.close();
	}

	//Compression helper method
	public void compressHelper(BufferedReader input, HashMap<Character, String> charToCode, String huffTreeString, String pathNameCompressed) throws IOException
	{


		BufferedBitWriter writer=new BufferedBitWriter(pathNameCompressed);
		byte[] bytes=huffTreeString.getBytes();

		//this String to bits code comes from https://stackoverflow.com/questions/917163/convert-a-string-like-testing123-to-binary-in-java accessed October 17th 2017
		StringBuilder binary=new StringBuilder();
		for (byte b : bytes)
		{
			int val = b;
			for (int i = 0; i < 8; i++)
			{
				binary.append((val & 128) == 0 ? 0 : 1);
				val <<= 1;
			}

		}

		for(int i=0;i<binary.length();i++)
		{
			if(binary.charAt(i)=='0')
			{
				writer.writeBit(false);
			}
			else
			{
				writer.writeBit(true);
			}
		}
		//making special character 00000000 that tells my decompression algorithm where treecode ends
		for(int i=0;i<8;i++)
		{
			writer.writeBit(false);
		}

		//writing the bit representation of the original file into the new file
		int cInt=input.read();
		while(cInt!=-1)
		{

			String code=charToCode.get((char)cInt);

			for(int i=0;i<code.length();i++)
			{
				if(code.charAt(i)=='0')
				{
					writer.writeBit(false);
				}
				else
				{
					writer.writeBit(true);
				}
			}
			cInt=input.read();
		}

		writer.close();

	}



	//helper method that converts a string into a binary tree, this is used in my decompression algorithm to convert the tree code into a usable binary tree
	public BinaryTree<HuffData> stringToBT(String toParse)
	{
		String[] leaves=toParse.split("<>");

		//Boundary Case that there is only one letter
		if(leaves.length==1)
		{
			char loneChar=leaves[0].charAt(0);
			int frequency=Integer.parseInt(leaves[0].substring(2));
			return new BinaryTree<HuffData>(new HuffData('a',frequency),new BinaryTree<HuffData>(new HuffData(loneChar,frequency)),null);
		}

		//reconstructing the binary tree based on the data in toParse, which is the tree code
		PriorityQueue<BinaryTree<HuffData>> minFreqQueue=new PriorityQueue<BinaryTree<HuffData>>(new TreeComparator());
		for(int i=0;i<leaves.length;i++)
		{

			minFreqQueue.add(new BinaryTree<HuffData>(new HuffData(leaves[i].charAt(0),Integer.parseInt(leaves[i].substring(2)))));
		}
		while(minFreqQueue.size()>1)
		{
			BinaryTree<HuffData> T1=minFreqQueue.remove();
			BinaryTree<HuffData> T2=minFreqQueue.remove();
			BinaryTree<HuffData> combine=new BinaryTree<HuffData>(new HuffData('a',T1.getData().getFrequency()+T2.getData().getFrequency()),T1,T2);
			minFreqQueue.add(combine);
		}
		return minFreqQueue.remove();
	}

	//a helper method for the boundary case of a single letter
	public void compressHelperSingleLetter(String huffTreeString, String pathName, String pathNameCompressed, int frequency) throws IOException
	{
		BufferedBitWriter writer=new BufferedBitWriter(pathNameCompressed);
		byte[] bytes=huffTreeString.getBytes();

		//this String to bits code comes from https://stackoverflow.com/questions/917163/convert-a-string-like-testing123-to-binary-in-java accessed October 17th 2017
		StringBuilder binary=new StringBuilder();
		for (byte b : bytes)
		{
			int val = b;
			for (int i = 0; i < 8; i++)
			{
				binary.append((val & 128) == 0 ? 0 : 1);
				val <<= 1;
			}

		}

		for(int i=0;i<binary.length();i++)
		{


			if(binary.charAt(i)!=' ')
			{

				if(binary.charAt(i)=='0')
				{
					writer.writeBit(false);
				}
				else
				{
					writer.writeBit(true);
				}
			}

		}
		//making special character
		for(int i=0;i<8;i++)
		{
			writer.writeBit(false);
		}

		for(int i=0;i<frequency;i++)
		{
			writer.writeBit(false);
		}
		writer.close();

	}
}
